//! Code generator for TypeScript event types
//! Generates TypeScript definitions from Rust event_types module
//!
//! Run with: cargo run --bin codegen

use std::fs;
use std::path::Path;

/// Event type definition
struct EventDef {
    prop_name: &'static str,
    event_type: &'static str,
}

/// All event definitions - single source of truth
const EVENT_DEFINITIONS: &[EventDef] = &[
    EventDef { prop_name: "onClick", event_type: "click" },
    EventDef { prop_name: "onDoubleClick", event_type: "dblclick" },
    EventDef { prop_name: "onMouseDown", event_type: "mousedown" },
    EventDef { prop_name: "onMouseUp", event_type: "mouseup" },
    EventDef { prop_name: "onMouseMove", event_type: "mousemove" },
    EventDef { prop_name: "onMouseEnter", event_type: "mouseenter" },
    EventDef { prop_name: "onMouseLeave", event_type: "mouseleave" },
    EventDef { prop_name: "onHover", event_type: "hover" },
    EventDef { prop_name: "onKeyDown", event_type: "keydown" },
    EventDef { prop_name: "onKeyUp", event_type: "keyup" },
    EventDef { prop_name: "onKeyPress", event_type: "keypress" },
    EventDef { prop_name: "onFocus", event_type: "focus" },
    EventDef { prop_name: "onBlur", event_type: "blur" },
    EventDef { prop_name: "onScroll", event_type: "scroll" },
    EventDef { prop_name: "onWheel", event_type: "wheel" },
];

/// Additional event types that don't have props (internal events)
const INTERNAL_EVENT_TYPES: &[&str] = &["focusin", "focusout"];

fn generate_typescript() -> String {
    let mut output = String::new();

    // Header
    output.push_str("/**\n");
    output.push_str(" * Auto-generated event types - DO NOT EDIT\n");
    output.push_str(" * Generated by: cargo run --bin codegen\n");
    output.push_str(" * Source: rust/src/bin/codegen.rs\n");
    output.push_str(" */\n\n");

    // Event type union
    output.push_str("/** All GPUI event types */\n");
    output.push_str("export type GPUIEventType =\n");
    for (i, def) in EVENT_DEFINITIONS.iter().enumerate() {
        output.push_str(&format!("    | \"{}\"", def.event_type));
        if i < EVENT_DEFINITIONS.len() - 1 || !INTERNAL_EVENT_TYPES.is_empty() {
            output.push('\n');
        }
    }
    for (i, event_type) in INTERNAL_EVENT_TYPES.iter().enumerate() {
        output.push_str(&format!("    | \"{}\"", event_type));
        if i < INTERNAL_EVENT_TYPES.len() - 1 {
            output.push('\n');
        }
    }
    output.push_str(";\n\n");

    // Event prop names union
    output.push_str("/** React-style event handler prop names */\n");
    output.push_str("export type GPUIEventPropName =\n");
    for (i, def) in EVENT_DEFINITIONS.iter().enumerate() {
        output.push_str(&format!("    | \"{}\"", def.prop_name));
        if i < EVENT_DEFINITIONS.len() - 1 {
            output.push('\n');
        }
    }
    output.push_str(";\n\n");

    // Prop to event type mapping
    output.push_str("/** Maps React prop names to event types */\n");
    output.push_str("export const EVENT_PROP_TO_TYPE = {\n");
    for def in EVENT_DEFINITIONS {
        output.push_str(&format!("    {}: \"{}\",\n", def.prop_name, def.event_type));
    }
    output.push_str("} as const;\n\n");

    // Event type to prop mapping
    output.push_str("/** Maps event types to React prop names */\n");
    output.push_str("export const EVENT_TYPE_TO_PROP = {\n");
    for def in EVENT_DEFINITIONS {
        output.push_str(&format!("    {}: \"{}\",\n", def.event_type, def.prop_name));
    }
    output.push_str("} as const;\n\n");

    // Helper function
    output.push_str("/** Check if a prop name is an event handler */\n");
    output.push_str("export function isEventHandlerProp(prop: string): prop is GPUIEventPropName {\n");
    output.push_str("    return prop in EVENT_PROP_TO_TYPE;\n");
    output.push_str("}\n\n");

    // Event type categories
    output.push_str("/** Mouse event types */\n");
    output.push_str("export const MOUSE_EVENT_TYPES = [\n");
    for def in EVENT_DEFINITIONS.iter().filter(|d| {
        d.event_type.starts_with("mouse")
            || d.event_type == "click"
            || d.event_type == "dblclick"
            || d.event_type == "hover"
    }) {
        output.push_str(&format!("    \"{}\",\n", def.event_type));
    }
    output.push_str("] as const;\n\n");

    output.push_str("/** Keyboard event types */\n");
    output.push_str("export const KEYBOARD_EVENT_TYPES = [\n");
    for def in EVENT_DEFINITIONS.iter().filter(|d| d.event_type.starts_with("key")) {
        output.push_str(&format!("    \"{}\",\n", def.event_type));
    }
    output.push_str("] as const;\n\n");

    output.push_str("/** Focus event types */\n");
    output.push_str("export const FOCUS_EVENT_TYPES = [\n");
    for def in EVENT_DEFINITIONS.iter().filter(|d| {
        d.event_type == "focus" || d.event_type == "blur"
    }) {
        output.push_str(&format!("    \"{}\",\n", def.event_type));
    }
    for event_type in INTERNAL_EVENT_TYPES.iter().filter(|t| {
        t.starts_with("focus")
    }) {
        output.push_str(&format!("    \"{}\",\n", event_type));
    }
    output.push_str("] as const;\n\n");

    output.push_str("/** Scroll event types */\n");
    output.push_str("export const SCROLL_EVENT_TYPES = [\n");
    for def in EVENT_DEFINITIONS.iter().filter(|d| {
        d.event_type == "scroll" || d.event_type == "wheel"
    }) {
        output.push_str(&format!("    \"{}\",\n", def.event_type));
    }
    output.push_str("] as const;\n");

    output
}

fn generate_rust_event_types() -> String {
    let mut output = String::new();

    // Header
    output.push_str("//! Auto-generated event type constants - DO NOT EDIT\n");
    output.push_str("//! Generated by: cargo run --bin codegen\n");
    output.push_str("//! Source: rust/src/bin/codegen.rs\n\n");
    output.push_str("#![allow(dead_code)] // Many constants are defined for completeness and code generation\n\n");

    // Props module
    output.push_str("/// Maps React-style prop names to standard event type names\n");
    output.push_str("/// Used when checking if an element has a handler registered\n");
    output.push_str("pub mod props {\n");
    for def in EVENT_DEFINITIONS {
        let const_name = prop_to_const_name(def.prop_name);
        output.push_str(&format!("    pub const {}: &str = \"{}\";\n", const_name, def.prop_name));
    }
    output.push_str("}\n\n");

    // Types module
    output.push_str("/// Standard event type names dispatched to JavaScript\n");
    output.push_str("/// These match the GPUIEventType in TypeScript\n");
    output.push_str("pub mod types {\n");
    for def in EVENT_DEFINITIONS {
        let const_name = event_type_to_const_name(def.event_type);
        output.push_str(&format!("    pub const {}: &str = \"{}\";\n", const_name, def.event_type));
    }
    for event_type in INTERNAL_EVENT_TYPES {
        let const_name = event_type_to_const_name(event_type);
        output.push_str(&format!("    pub const {}: &str = \"{}\";\n", const_name, event_type));
    }
    output.push_str("}\n\n");

    // Conversion function
    output.push_str("/// Convert prop name to event type\n");
    output.push_str("/// Returns None if the prop is not a recognized event handler\n");
    output.push_str("pub fn prop_to_event_type(prop: &str) -> Option<&'static str> {\n");
    output.push_str("    match prop {\n");
    for def in EVENT_DEFINITIONS {
        let prop_const = prop_to_const_name(def.prop_name);
        let type_const = event_type_to_const_name(def.event_type);
        output.push_str(&format!("        props::{} => Some(types::{}),\n", prop_const, type_const));
    }
    output.push_str("        _ => None,\n");
    output.push_str("    }\n");
    output.push_str("}\n");

    output
}

/// Convert prop name like "onClick" to const name like "ON_CLICK"
fn prop_to_const_name(prop: &str) -> String {
    let mut result = String::new();
    for (i, c) in prop.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_uppercase());
        } else {
            result.push(c.to_ascii_uppercase());
        }
    }
    result
}

/// Convert event type like "mousedown" to const name like "MOUSEDOWN"
fn event_type_to_const_name(event_type: &str) -> String {
    event_type.to_uppercase()
}

fn main() {
    // Get project root (assumes we're running from rust/ directory or project root)
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR")
        .unwrap_or_else(|_| ".".to_string());
    let rust_dir = Path::new(&manifest_dir);
    let project_root = rust_dir.parent().unwrap_or(rust_dir);

    // Generate TypeScript file
    let ts_output = generate_typescript();
    let ts_path = project_root.join("src/events/generated.ts");

    if let Some(parent) = ts_path.parent() {
        fs::create_dir_all(parent).expect("Failed to create events directory");
    }

    fs::write(&ts_path, &ts_output).expect("Failed to write TypeScript file");
    println!("Generated: {}", ts_path.display());

    // Generate Rust file
    let rust_output = generate_rust_event_types();
    let rust_path = rust_dir.join("src/event_types.rs");

    fs::write(&rust_path, &rust_output).expect("Failed to write Rust file");
    println!("Generated: {}", rust_path.display());

    println!("\nDone! Event type definitions are now synchronized.");
}
